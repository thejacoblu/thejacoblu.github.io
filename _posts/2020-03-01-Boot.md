---
layout: post
tags: xv6 中文实时 操作虚脱 你好 
author: jill
img_src: "assets/images/banana.jpg"
---
内存管理有两个部分。首先是关于内核的物理内存分配器，分配了实际的物理内存后，内核才能分配内存并在之后释放它。任务是维护记录着空闲页表和已分配页表的数据结构，以及多少进程在共享分配的页面。需要编写分配和释放页面的流程。

其次是虚拟内存管理。根据要求来修改JOS设置页表的方式。

`git checkout -b lab2 origin/lab2`

1. 基于origin/lab2建立本地的lab2分支
2. 改变lab下的内容来更新lab2分支的文件

新增/改动文件说明

| 文件名            |                                                              |
| ----------------- | ------------------------------------------------------------ |
| `inc/memlayout.h` | ⭐通过改动`pmap.c`，`pmap.h`以及`inc/memlayout.h`应该实现的虚拟地址空间的内存分布。 |
| `kern/pmap.c`     | 读取设备硬件来确定物理内存空间有多少。                       |
| `kern/pmap.h`     | ⭐可以也参考`inc/mmu.h`                                       |
| `kern/kclock.h`   | 管理PC的后备电池和CMOS RAM硬件，BIOS在其中记录PC的物理内存。 |
| `kern/kclock.c`   |                                                              |

## Part 1：Physical Page Management

JOS以页面为单位管理PC的物理内存，因此MMU可以通过映射来保护分配的内存。

编写一个物理页面分配器。使用以`struct PageInfo`为元素的链表来管理空闲页面。该链表不像xv6一样就存储在空闲页面中，而是要另外写。每个链表元素都对应着一个空闲的物理页面。



## Part 2：Virtual Memory

了解x86保护模式下的分段和页转换机制。



### Virtual，Linear and Physical Addresses

```
           Selector  +--------------+         +-----------+
          ---------->|              |         |           |
                     | Segmentation |         |  Paging   |
Software             |              |-------->|           |---------->  RAM
            Offset   |  Mechanism   |         | Mechanism |
          ---------->|              |         |           |
                     +--------------+         +-----------+
            Virtual                   Linear                Physical

```

C指针实际时虚拟地址的offset部分。在`boot/boot.S`中，通过加载GDT并设置所有的`base`和`limit`分别为`0`和`0xffffffff`来禁用了段转换功能。因此selector域没有任何的功能，并且线性地址永远等于虚拟地址。

JOS内核有时需要读取或修改物理地址的内存。例如，将映射添加到页表可能需要分配物理内存以存储页目录，然后初始化该内存。但是，内核无法绕过虚拟地址转换，因此无法直接加载并存储到物理地址。 

JOS将物理地址0开始的所有物理内存重映射到虚拟地址`0xf0000000`处的的原因之一是帮助内核仅知道物理地址时读写内存。能够将物理地址转换为内核可以实际读写的虚拟地址，内核必须在物理地址上添加`0xf0000000`才能在重映射区域中找到其对应的虚拟地址。应该使用`KADDR(pa)`进行添加。

JOS内核有时有时还需要能够根据虚拟地址找到物理地址。 `boot_alloc()`分配的内核全局变量和内存位于加载内核的区域中，从`0xf0000000`开始，该区域正是我们映射所有物理内存的区域。因此，要将该区域中的虚拟地址转换为物理地址，内核可以简单地减去`0xf0000000`。应该使用`PADDR(va)`进行减法。